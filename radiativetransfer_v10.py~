# -*- coding: iso-8859-1 -*-
"""
This code is an implementation of the two-stream formalism from Toon et al 1989.
People to credit with thanks for helping us build this: S. Rugheimer, R. Ramirez,

This version adds the ability to control CO2 levels (constraint: mixing ratios of CO2 and N2 sum to 1).
This version also adds the ability to have H2S.
"""

########################
###Import useful libraries & define constants
########################

import numpy as np
import matplotlib.pyplot as plt
import format_feedstock_files_v4 as fff
import twostream_toon_func_alt as twostr
import radiativetransfer_subfunctions_v3 as rts
import radiativetransfer_albedo_subfunctions as ras
import pdb
from mpl_toolkits.mplot3d import Axes3D
import pickle
import cookbook

########################
###Constants
########################

bar2Ba=1.0e6 #1 bar in Ba
amu2g=1.66054e-24 #1 amu in g

########################
###User-set parameters
########################
filename='reproduce_rugheimer_foo' #name of file to write output, plot to

#TOA input, and comparison file.
inputspectrafile='./LiteratureSpectra/prebiotic_recomputed.dat' #TOA Stellar Input and Reference Spectra for Comparison

#Mixing ratio file
N_species=8 #how many gas species are in our model?
mr_profilefile='./MixingRatios/rugheimer_earth_epoch0_mixingratios_v2.dat' #Mixing ratio file

#T/P Profile.
atmoprofilefile='./TPProfiles/rugheimer_earth_epoch0_atmosphereprofile.dat' #T/P Profile File. File boundaries should match z_lower and z_upper
atmoprofilelines=104 #number of lines in atmospheric profile file.

###Atmospheric Surface Pressure
p_scale=1.0 #Factor to scale the atmospheric pressures and number densities by. This parameter is used to control the column density of the atmosphere, so we can see how varying surface pressure/density affects this quantity and hence UV transmission

#RT model layers
z_upper_limit=64.e5 #Upper edge of the atmospheric layers, in cm. The bottom edge of the layers is assumed to be at 0.
z_step=1.e5 # Thickness of the atmospheric layers, in cm.

###Solar Zenith Angle
solarzenithangle=60.*np.pi/180. #60 degrees (pi/3) used by Rugheimer et al in their paper.

###Albedo
#Uniform albedo: set flag to 'uniformalbedo' and set the subsequent albedo value
#Nonuniform albedo: set flag to 'nonuniformalbedo' and choose what mix of surface: ocean, old snow, new snow, desert, tundra. 
#set flag to 'plot' to plot albedo used. 
albedoflag='uniformalbedo' #value of 'nonuniformalbedo' or 'uniformalbedo'
uniformalbedo=0.20 #if adopting uniform albedo: what value?
frac_ocean=0. #if nonuniform albedo: what fraction of ground is ocean?
frac_tundra=0. #if nonuniform albedo: what fraction of ground is tundra?
frac_desert=0. #if nonuniform albedo: what fraction of ground is desert?
frac_oldsnow=0.#if nonuniform albedo: what fraction of ground is old snow?
frac_newsnow=0. #if nonuniform albedo: what fraction of ground is new snow?

###Temperature of Ground
temp_ground=292.5 #Temperature of the ground in K.

###Mixing ratio scalars
#Use these to scale the mixing ratio of the relevant gas relative to what the input mixing ratio file says.
#Use for quick-and-dirty tests to see how abundance affects the emergent spectrum.
n2_multiplier=1.
co2_multiplier=1.
so2_multiplier=1.
h2o_multiplier=1.
ch4_multiplier=1.
o2_multiplier=1.
o3_multiplier=1.
h2s_multiplier=1.

###2-gas atmosphere switch
#Use this to set the mixing ratios for different gases artificially. If set, instead of using the provided input file for mixing ratios, the code will use a uniform mixing ratio of the provided value. Constraint used is that mr_X+mr_N2=1 (i.e. N2 is used as the background gas). This procedure implicitly assumes a 2-gas atmosphere.
altergaslevel=False #if alterco2level=True, then you can set the CO2 level. 
gasname='co2'
gaslevel=0.0#mixing ratio. 0.1 should return the Rugheimer base case.
###Set output file names
writefilename='./TwoStreamOutput/'+filename+'.dat' #name of file to write output to. 
plotfilename='./Plots/'+filename+'.pdf' #name of file to save plot to.
########################
###Set angular parameters relevant to the RT model
########################
mu_0=np.cos(solarzenithangle)#Cosine of solar zenith angle.
mu_1=1./np.sqrt(3.) #The Gaussian quadrature angle for the diffuse flux direction.

########################
###Load in TOA stellar input
########################
importeddata=np.genfromtxt(inputspectrafile, skip_header=1, skip_footer=0)
wav_leftedges=importeddata[:,0] #left edges of wavelength bins, nm
wav_rightedges=importeddata[:,1] #right edges of wavelength bins, nm
wav_centers=importeddata[:,2] #centers of wavelength bins, nm
intensity_toa=importeddata[:,3] #top-of-atmosphere total intensity, erg/s/cm2/nm. Multiply by mu_0 to get TOA flux.
surface_intensity_basecase=importeddata[:,4] #total surface intensity computed for the baseline Rugheimer+2015 3.9 Ga atmosphere, erg/s/cm2/nm. Included for comparison purposes.

N_wavelengths=len(wav_centers)
wav_edges=np.append(wav_leftedges, wav_rightedges[-1])
########################
###Load other key inputs
########################

###Layers of the atmosphere
#This is required for all variants of running the code
z_lower, z_center, z_upper, N_layers=rts.get_z_layers(z_upper_limit, z_step) #define layers of atmosphere.
z_edges=np.append(z_upper, z_lower[-1])


###Mixing ratios
#Set the mixing ratios of the gases. If set to a number, the gas is assumed to be well-mixed, i.e. have this mixing ratio everywhere in the column. If set to a filename, the mixing ratio is taken from that file.
mr_n2=rts.get_mixing_ratios(z_center, mr_profilefile, 'n2')*n2_multiplier
mr_co2=rts.get_mixing_ratios(z_center, mr_profilefile, 'co2')*co2_multiplier
mr_h2o=rts.get_mixing_ratios(z_center, mr_profilefile, 'h2o')*h2o_multiplier
mr_ch4=rts.get_mixing_ratios(z_center, mr_profilefile, 'ch4')*ch4_multiplier
mr_so2=rts.get_mixing_ratios(z_center, mr_profilefile, 'so2')*so2_multiplier
mr_o2=rts.get_mixing_ratios(z_center, mr_profilefile, 'o2')*o2_multiplier
mr_o3=rts.get_mixing_ratios(z_center, mr_profilefile, 'o3')*o3_multiplier
mr_h2s=rts.get_mixing_ratios(z_center, mr_profilefile, 'h2s')*h2s_multiplier

if altergaslevel: #if we are manually setting the CO2 level to a certain value, then:
	n2level=1.-gaslevel #mixing ratio. 
	mr_n2=np.zeros(np.shape(mr_n2))+n2level
	
	if gasname=='co2':
		mr_co2=np.zeros(np.shape(mr_co2))+gaslevel
	if gasname=='ch4':
		mr_ch4=np.zeros(np.shape(mr_ch4))+gaslevel
	if gasname=='so2':
		mr_so2=np.zeros(np.shape(mr_so2))+gaslevel
	if gasname=='h2o':
		mr_h2o=np.zeros(np.shape(mr_h2o))+gaslevel
	if gasname=='o2':
		mr_o2=np.zeros(np.shape(mr_o2))+gaslevel
	if gasname=='o3':
		mr_o3=np.zeros(np.shape(mr_o3))+gaslevel
	if gasname=='h2s':
		mr_h2s=np.zeros(np.shape(mr_h2s))+gaslevel
#pdb.set_trace()
####Albedos
albedo_dif_wav=ras.get_surface_albedo(wav_leftedges, wav_rightedges,solarzenithangle, albedoflag, uniformalbedo, frac_ocean,frac_oldsnow,frac_newsnow,frac_desert,frac_tundra, 'noplot', 'diffuse')
albedo_dir_wav=ras.get_surface_albedo(wav_leftedges, wav_rightedges,solarzenithangle, albedoflag, uniformalbedo, frac_ocean,frac_oldsnow,frac_newsnow,frac_desert,frac_tundra, 'noplot', 'direct')

########################
###Load absorption and scattering cross-sections.
########################
#Initialize variables to hold scattering cross-sections
xc_tot_species_wav=np.zeros([N_species,N_wavelengths])
xc_scat_species_wav=np.zeros([N_species,N_wavelengths])
xc_abs_species_wav=np.zeros([N_species,N_wavelengths])

#Load in band-averaged cross-sections.  
#Function called returns xc in cm2/molecule in each band (total extinction, absorption, and rayleigh scattering). tot=abs+ray.

(xc_tot_species_wav[0,:], xc_abs_species_wav[0,:], xc_scat_species_wav[0,:])=fff.compute_band_cross_section(wav_leftedges, wav_rightedges, 'n2')
(xc_tot_species_wav[1,:], xc_abs_species_wav[1,:], xc_scat_species_wav[1,:])=fff.compute_band_cross_section(wav_leftedges, wav_rightedges, 'co2')
(xc_tot_species_wav[2,:], xc_abs_species_wav[2,:], xc_scat_species_wav[2,:])=fff.compute_band_cross_section(wav_leftedges, wav_rightedges, 'h2o')
(xc_tot_species_wav[3,:], xc_abs_species_wav[3,:], xc_scat_species_wav[3,:])=fff.compute_band_cross_section(wav_leftedges, wav_rightedges, 'ch4')
(xc_tot_species_wav[4,:], xc_abs_species_wav[4,:], xc_scat_species_wav[4,:])=fff.compute_band_cross_section(wav_leftedges, wav_rightedges, 'so2')
(xc_tot_species_wav[5,:], xc_abs_species_wav[5,:], xc_scat_species_wav[5,:])=fff.compute_band_cross_section(wav_leftedges, wav_rightedges, 'o2')
(xc_tot_species_wav[6,:], xc_abs_species_wav[6,:], xc_scat_species_wav[6,:])=fff.compute_band_cross_section(wav_leftedges, wav_rightedges, 'o3')
(xc_tot_species_wav[7,:], xc_abs_species_wav[7,:], xc_scat_species_wav[7,:])=fff.compute_band_cross_section(wav_leftedges, wav_rightedges, 'h2s')

#Note that in some cases, the predicted Rayleigh scattering cross-section exceeds that measured in laboratory studies. This means that 1) the single-scattering albedo w_0>1 in these cases and 2) the absorption cross-section is negative (both unphysical). This is accounted for in the two-stream code, where w_0 is set to a maximum of 0.999. The only parameters used in the radiative transfer are w_0 and tau_tot, so the negative absorption cross-sections never come into play. 


#Try Rugheimer cross-sections and scattering instead
(xc_tot_species_wav[0,:], xc_abs_species_wav[0,:], xc_scat_species_wav[0,:])=fff.get_rugheimer_xc(wav_leftedges, wav_rightedges, 'n2',0.78, 0.)
#(xc_tot_species_wav[0,:], xc_abs_species_wav[0,:], xc_scat_species_wav[0,:])=fff.get_rugheimer_xc(wav_leftedges, wav_rightedges, 'n2',0.92, 0.1)
(xc_tot_species_wav[1,:], xc_abs_species_wav[1,:], xc_scat_species_wav[1,:])=fff.get_rugheimer_xc(wav_leftedges, wav_rightedges, 'co2',0,0)
(xc_tot_species_wav[2,:], xc_abs_species_wav[2,:], xc_scat_species_wav[2,:])=fff.get_rugheimer_xc(wav_leftedges, wav_rightedges, 'h2o',0,0)
(xc_tot_species_wav[4,:], xc_abs_species_wav[4,:], xc_scat_species_wav[4,:])=fff.get_rugheimer_xc(wav_leftedges, wav_rightedges, 'so2',0,0)
(xc_tot_species_wav[5,:], xc_abs_species_wav[5,:], xc_scat_species_wav[5,:])=fff.get_rugheimer_xc(wav_leftedges, wav_rightedges, 'o2',0,0)
(xc_tot_species_wav[6,:], xc_abs_species_wav[6,:], xc_scat_species_wav[6,:])=fff.get_rugheimer_xc(wav_leftedges, wav_rightedges, 'o3',0,0)
#Rugheimer has no CH4 or H2S so we keep our own, but get rid of the scattering formalism 
xc_scat_species_wav[3,:]=xc_scat_species_wav[3,:]*0.0
xc_scat_species_wav[7,:]=xc_scat_species_wav[7,:]*0.0

########################
###Get atmospheric layers column densities
########################

#extract integrated column densities for each layer in this atmosphere
n_z, t_z, p_z, columndensity_z, t_c=rts.get_atmospheric_profile(z_lower, z_upper, atmoprofilefile,atmoprofilelines, p_scale)

#Compute column densities
colden_species_z=np.zeros([N_species,N_layers])
colden_species_z[0,:]=columndensity_z*mr_n2
colden_species_z[1,:]=columndensity_z*mr_co2
colden_species_z[2,:]=columndensity_z*mr_h2o
colden_species_z[3,:]=columndensity_z*mr_ch4
colden_species_z[4,:]=columndensity_z*mr_so2
colden_species_z[5,:]=columndensity_z*mr_o2
colden_species_z[6,:]=columndensity_z*mr_o3
colden_species_z[7,:]=columndensity_z*mr_h2s


#total_colden_species=np.sum(colden_species_z,axis=1)
#total_colden=np.sum(columndensity_z) #different from sum of colden_species_z b/c the Rugheimer mixing ratios aren't perfectly normalized...
#print total_colden_species/total_colden
#pdb.set_trace()
#columndensity_z
########################
###Compute atmospheric optical parameters required for two-stream code: tau_n, tau_c, w0, and g in each layer as a function of wavelength.
########################

#Call subfunction to extract composite values
tau_n_tot_z_wav, tau_c_tot_z_wav, w_0_z_wav, g_z_wav=rts.compute_optical_parameters(colden_species_z,xc_tot_species_wav, xc_scat_species_wav,0)
#Reminder: Toon et al define their albedo with tau=0 at the TOA, and it is computed along the zenith direction (so solar zenith angle is accounted for separately in the code).

##Code to set scattering or absorption limits
#w_0_z_wav=w_0_z_wav*0.0+1.e-5#pure absorption limit
#w_0_z_wav=w_0_z_wav*0.0+0.99999#pure scattering limit
#pdb.set_trace()

########################
###compute the flux via the two-stream approximation
########################
F_plus_tau0=np.zeros(np.shape(tau_n_tot_z_wav)) #F_plus evaluated at tau=0 for every layer n
F_plus_taumax=np.zeros(np.shape(tau_n_tot_z_wav))#F_plus evaluated at tau=tau_n[n] for every layer n
F_minus_tau0=np.zeros(np.shape(tau_n_tot_z_wav))#F_minus evaluated at tau=0 for every layer n
F_minus_taumax=np.zeros(np.shape(tau_n_tot_z_wav))#F_minus evaluated at tau=tau_n[n] for every layer n

F_net=np.zeros(np.shape(tau_n_tot_z_wav))#Net flux at the BASE of layer n. 
AMEAN=np.zeros(np.shape(tau_n_tot_z_wav))#AMEAN, 4*pi*mean intensity at the base of layer n. 
SS=np.zeros(np.shape(intensity_toa)) #This quantity is the SS quantity from twostr.f.
surface_intensity=np.zeros(np.shape(intensity_toa)) #an  estimate of the total amount of intensity received by a point at the surface of the planet. It is equal to the direct intensity plus F_[surface]/mu_1, i.e. the downward diffuse intensity at the surface

#Core loop over wavelength:
for ind in range(0,N_wavelengths):
	wavelength=wav_centers[ind] #width doesn't matter as wav primarily matters for BB which varies in smooth way.
	solar_input=intensity_toa[ind]/np.pi #this converts the TOA flux to the F_s in Toon et al. Recall pi*F_s=solar flux (really solar intensity) in that formalism.
	w_0=w_0_z_wav[:,ind]
	
	g=g_z_wav[:,ind]
	tau_n=tau_n_tot_z_wav[:,ind]
	albedo_dif=albedo_dif_wav[ind]
	albedo_dir=albedo_dir_wav[ind]
	
	thunk1, thunk2, thunk3, thunk4, thunk5, thunk6, thunk7=twostr.twostr_func(wavelength, solar_input, solarzenithangle, albedo_dif, albedo_dir,temp_ground, w_0, g, tau_n, t_c)
	
	F_plus_tau0[:,ind]=thunk1
	F_plus_taumax[:,ind]=thunk2
	F_minus_tau0[:, ind]=thunk3
	F_minus_taumax[:,ind]=thunk4
	
	F_net[:,ind]=thunk5
	AMEAN[:,ind]=thunk6
	
	SS[ind]=np.sqrt(thunk6[-1]*thunk6[-2])
	surface_intensity[ind]=thunk7
	
	
	fnetcol=thunk5
	med_fnet=np.median(fnetcol)
	fnetdev=np.max(np.abs(fnetcol-med_fnet))/(mu_0*intensity_toa[ind])

########################
###Compute the direct fluxes throughout the atmosphere, and the surface flux.
########################


direct_flux_z_wav=mu_0*intensity_toa*np.exp(-tau_c_tot_z_wav/mu_0) #Direct flux at the boundary of each layer. First layer=TOA, last layer=surface. See: Toon et al eqn 50, and recall: flux_toa=F_s*np.pi

surface_direct_flux=direct_flux_z_wav[-1,:] #Get the direct flux at the surface
surface_diffuse_flux=F_minus_taumax[-1,:] #Get downwelling diffuse flux at the bottom layer, i.e. the surface

surface_flux=surface_diffuse_flux+surface_direct_flux


########################
###Compute the surface intensity at the base of the atmosphere, and compare to what is reported by the code.
########################
direct_intensity_z_wav=intensity_toa*np.exp(-tau_c_tot_z_wav/mu_0) #Direct intensity at the boundary of each layer, with first layer=TOA and last layer=BOA. 

surface_direct_intensity=direct_intensity_z_wav[-1,:] #direct intensity at base of atmosphere

surface_diffuse_intensity=F_minus_taumax[-1,:]/mu_1 #diffuse intensity at base of atmosphere.

surface_intensity_2=surface_direct_intensity+surface_diffuse_intensity

###Check for consistency:
surf_int_diff=(surface_intensity-surface_intensity_2)/surface_intensity
print np.max(np.abs(surf_int_diff))
#pdb.set_trace()

########################
###Check energy conservation
########################
incoming_flux_tot=np.sum(mu_0*intensity_toa)

outgoing_flux_tot=np.sum(F_plus_tau0[0,:])

if outgoing_flux_tot <= incoming_flux_tot:
	print 'Outgoing Flux<= Incoming Flux: Consistent with Energy Conservation'
if outgoing_flux_tot > incoming_flux_tot:
	print 'Outgoing Flux > Incoming Flux: Energy Conservation Violated DANGER DANGER DANGER'

########################
###Some diagnostics, useful for the paper:
########################

columndensity_z
print 'Total column density is (cm-2):', np.sum(columndensity_z)
print 'N2 column density is (cm-2):', np.sum(colden_species_z[0,:])
print 'CO2 column density is (cm-2):', np.sum(colden_species_z[1,:])
print 'H2O column density is (cm-2):', np.sum(colden_species_z[2,:])
print 'CH4 column density is (cm-2):', np.sum(colden_species_z[3,:])
print 'SO2 column density is (cm-2):', np.sum(colden_species_z[4,:])
print 'O2 column density is (cm-2):', np.sum(colden_species_z[5,:])
print 'O3 column density is (cm-2):', np.sum(colden_species_z[6,:])# used to check against R+2015 table 1
print 'H2S column density is (cm-2):', np.sum(colden_species_z[7,:])

inds=np.where(surface_intensity/intensity_toa<0.01)
indmax=np.max(inds) #here I assume monotonically decreasing
print 'index at which intensity suppressed to 0.01 x incident is:', indmax
print 'wavelength at which intensity suppressed 0.01 x incident is (nm):', wav_rightedges[indmax]
#pdb.set_trace()
#########################
####Plot results
#########################

fig, (ax1, ax2)=plt.subplots(2, figsize=(8,6), sharex=True)
ax1.plot(wav_centers, intensity_toa, marker='s', color='black', label='TOA Intensity')
ax1.plot(wav_centers, surface_intensity_basecase, marker='s', color='blue', label='BOA Intensity (Rugheimer Base Case)')
ax1.plot(wav_centers, SS, marker='s', color='orange', label='BOA Intensity (This Model)')
ax1.set_yscale('log')
ax1.set_ylim([1.e-4, 1.e4])
ax1.set_xlim([100.,900.])
ax1.set_xlabel('nm')
ax1.set_ylabel('erg/s/cm2/nm')
ax1.legend(loc=0)

ax2.plot(wav_centers, (SS-surface_intensity_basecase)/intensity_toa, marker='s', color='orange', label='Fractional Difference')
ax2.set_yscale('linear')
#ax2.set_ylim([-0.006, 0.006])
ax2.set_xlim([100.,900.])
ax2.set_xlabel('nm')
ax2.set_ylabel('Fractional Difference')
plt.savefig(plotfilename, orientation='portrait',papertype='letter', format='pdf')

############################
#######Print spectra
############################
toprint=np.zeros([np.size(wav_centers), 9])
toprint[:,0]=wav_leftedges #left edge of wavelength bin (nm)
toprint[:,1]=wav_rightedges #right edge of wavelength bin (nm)
toprint[:,2]=wav_centers #center of wavelength bin (nm)
toprint[:,3]=intensity_toa #intensity incident at top of atmosphere (erg/s/cm2/nm)
toprint[:,4]=surface_flux #flux incident at bottom of atmosphere (erg/s/cm2/nm)
toprint[:,5]=SS #total intensity (4\pi J) in middle of bottom layer of atmosphere, same as what CLIMA code reports (erg/s/cm2/nm)
toprint[:,6]=surface_intensity #total intensity incident on surface. It is equal to sum of direct intensity and diffuse downward intensity. (erg/s/cm2/nm)
toprint[:,7]=surface_diffuse_intensity #total downward diffuse intensity at surface, i.e. 2\pi*I_minus[N]. (erg/s/cm2/nm)
toprint[:,8]=surface_direct_intensity #total direct intensity incident at surface, i.e. I_0*exp(-tau_0/mu_0). (erg/s/cm2/nm)


header='Left Bin Edge (nm)	Right Bin Edge (nm)	Bin Center (nm)		Top of Atm Intensity (erg/s/nm/cm2)		Total Surface Flux (erg/s/nm/cm2)		Total Intensity at BOA (erg/s/nm/cm2)		Total Surface Intensity (erg/s/nm/cm2)		Total Surface Diffuse Intensity (erg/s/nm/cm2)		Total Surface Direct Intensity (erg/s/nm/cm2)\n'
f=open(writefilename, 'w')
f.write(header)
np.savetxt(f, toprint, delimiter='		', fmt='%1.7e', newline='\n')
f.close()

plt.show()

"""
********************************************************************************
SCRATCH CODE
********************************************************************************
"""

#################################
############One-time test plot: do we match Rugheimer?
#################################
#####importeddata=np.genfromtxt('/home/sranjan/Python/UV/RadiativeTransfer/TwoStreamOutput/reproduce_rugheimer_epoch0_ourxc_a=0.245.dat.dat', skip_header=1, skip_footer=0)
#####rugh_centers=importeddata[:,2] #centers of wavelength bins, nm
#####rugh_toa=importeddata[:,3] #top-of-atmosphere total intensity, erg/s/cm2/nm
#####rugh_boa=importeddata[:,5] #SS published for the baseline Rugheimer+2015 3.9 Ga atmosphere, erg/s/cm2/nm

#####pdb.set_trace()
#####fig1, (ax1)=plt.subplots(1, figsize=(6,4), sharex=True)
#####ax1.plot(rugh_centers, rugh_toa, marker='s', color='black', label='TOA Intensity (Rugheimer)')
#####ax1.plot(rugh_centers, rugh_boa, marker='s', color='blue', label='Twostr SS (Rugheimer Plot)')
#####ax1.plot(wav_centers, intensity_toa, marker='s', color='red', label='TOA Intensity (This Model)')
#####ax1.plot(wav_centers, SS, marker='s', color='orange', label='Twostr SS (This Model)')
#####ax1.set_yscale('log')
#####ax1.set_ylim([1.e-2, 1.e4])
#####ax1.set_xlim([100.,900.])
#####ax1.set_xlabel('nm')
#####ax1.set_ylabel('erg/s/cm2/nm')
#####ax1.legend(loc=0)



##Try Rugheimer cross-sections and scattering instead
#(xc_tot_species_wav[0,:], xc_abs_species_wav[0,:], xc_scat_species_wav[0,:])=fff.get_rugheimer_xc(wav_leftedges, wav_rightedges, 'n2',0.78, 0.)
##(xc_tot_species_wav[0,:], xc_abs_species_wav[0,:], xc_scat_species_wav[0,:])=fff.get_rugheimer_xc(wav_leftedges, wav_rightedges, 'n2',0.92, 0.1)
#(xc_tot_species_wav[1,:], xc_abs_species_wav[1,:], xc_scat_species_wav[1,:])=fff.get_rugheimer_xc(wav_leftedges, wav_rightedges, 'co2',0,0)
#(xc_tot_species_wav[2,:], xc_abs_species_wav[2,:], xc_scat_species_wav[2,:])=fff.get_rugheimer_xc(wav_leftedges, wav_rightedges, 'h2o',0,0)
#(xc_tot_species_wav[4,:], xc_abs_species_wav[4,:], xc_scat_species_wav[4,:])=fff.get_rugheimer_xc(wav_leftedges, wav_rightedges, 'so2',0,0)
#(xc_tot_species_wav[5,:], xc_abs_species_wav[5,:], xc_scat_species_wav[5,:])=fff.get_rugheimer_xc(wav_leftedges, wav_rightedges, 'o2',0,0)
#(xc_tot_species_wav[6,:], xc_abs_species_wav[6,:], xc_scat_species_wav[6,:])=fff.get_rugheimer_xc(wav_leftedges, wav_rightedges, 'o3',0,0)
##Rugheimer has no CH4, so we keep our own, but get rid of the scattering formalism 
#xc_scat_species_wav[3,:]=xc_scat_species_wav[3,:]*0.0

#######Try Patel cross-sectiuons instead
######(xc_tot_species_wav[0,:], xc_abs_species_wav[0,:], xc_scat_species_wav[0,:])=fff.get_patel_xc(wav_leftedges, wav_rightedges, 'n2')
######(xc_tot_species_wav[1,:], xc_abs_species_wav[1,:], xc_scat_species_wav[1,:])=fff.get_patel_xc(wav_leftedges, wav_rightedges, 'co2')
######(xc_tot_species_wav[2,:], xc_abs_species_wav[2,:], xc_scat_species_wav[2,:])=fff.get_patel_xc(wav_leftedges, wav_rightedges, 'h2o')
######(xc_tot_species_wav[5,:], xc_abs_species_wav[5,:], xc_scat_species_wav[5,:])=fff.get_patel_xc(wav_leftedges, wav_rightedges, 'o2')
######(xc_tot_species_wav[6,:], xc_abs_species_wav[6,:], xc_scat_species_wav[6,:])=fff.get_patel_xc(wav_leftedges, wav_rightedges, 'o3')


#pdb.set_trace()
#figN, ax=plt.subplots(1, figsize=(6,4))
#ax.plot(wav_centers, np.sum(colden_species_z[6,:])*xc_tot_species_wav[6,:], color='black', label='Ozone CD*Ozone XC')
#ax.plot(wav_centers, np.sum(colden_species_z[5,:])*xc_tot_species_wav[5,:], color='black', label='Oxygen Cd*Oxygen XC')
#ax.plot(wav_centers, tau_c_tot_z_wav[-1,:], color='red', label='Optical Depth')
#ax.set_yscale('log')
#ax.set_ylim([1.e-1, 1.e2])
#ax.set_xlim([200., 400.])
#ax.legend(loc=0)

#figM, ax=plt.subplots(1, figsize=(6,4))
#ax.plot(wav_centers, np.exp(-tau_c_tot_z_wav[-1,:]/mu_0), color='red', label='Direct Intensity')
#ax.set_yscale('log')
#ax.set_ylim([1.e-5, 1.e0])
#ax.set_xlim([200., 400.])
#ax.legend(loc=0)

#####For plotting the differences between our codes: 
##if both our codes report zero, ratio should be 1.
#foo=np.where((flux_gnd==0.) & (SS==0.))
#flux_gnd[foo]=1.
#SS[foo]=1.
#pdb.set_trace()
##If our code has BB emission turned on AND the other flux is zero, we are probably just included BB emission and they are not; so, turn their thing off.
#flux_gnd[flux_gnd==0.]=np.float('NaN')

####Plot the total optical depth and number density-weighted mixing ratio as a function of wavelength as a check on the optical parameters
#total_optical_depth=tau_c_tot_z_wav[-1,:]
#total_w_0_wav=np.zeros(N_wavelengths)
#for ind in range(0,N_wavelengths):
	#total_w_0_wav[ind]=np.sum(w_0_z_wav[:,ind]*columndensity_z)/np.sum(columndensity_z)

#fig1, (ax1, ax2)=plt.subplots(2, figsize=(12,10), sharex=True)
#ax1.plot(wav_centers, total_optical_depth, marker='s', color='black', label='Total Optical Depth')
#ax1.plot(wav_centers, wav_centers*0.0+1.0, color='red', linestyle='--')
#ax1.set_yscale('log')
#ax1.set_ylim([1.e-3, 1.e3])
#ax1.set_xlim([130.,855.])
#ax1.legend(loc=0)

#ax2.plot(wav_centers,total_w_0_wav, marker='s', color='red', label='w_0')
#ax2.set_yscale('log')
#ax2.set_ylim([1.e-3,1.])
#ax2.legend(loc=0)

#plt.savefig(plotfilename+'_opticalparameters.pdf', orientation='portrait',papertype='letter', format='pdf')


#####fig2, (ax1)=plt.subplots(1, figsize=(8,6))
#####ax1.plot(wav_centers, tau_c_tot_z_wav[-1,:], marker='s', color='black')
#####ax1.axvline(186.9, 0, 1, color='red', linestyle='--')
#####ax1.axvline(204.1, 0, 1, color='red', linestyle='--')
#####ax1.axvline(327.5, 0, 1, color='red', linestyle='--')
#####ax1.axhline(1., 0, 1, color='green', linestyle='--')
#####ax1.set_yscale('log')
#####ax1.set_ylabel('Cumulative Optical Depth')
#####ax1.set_xlabel('Wavelength (nm)')
#####plt.savefig('/home/sranjan/Python/UV/RadiativeTransfer/Plots/tau_c.pdf', orientation='portrait',papertype='letter', format='pdf')


#####fig,ax=plt.subplots(1, figsize=(6,4))
#####ax.pcolor(tau_n_tot_z_wav, cmap=plt.cm.Reds, edgecolors='k')
#####ax.set_xticks(wav_centers)
#####ax.set_yticks(z_center*1.e-5)
#####plt.ylabel('Altitude (km)')
#####plt.xlabel('Wavelength (nm)')
#####plt.title('Layer Optical Depth')

#####fig=plt.figure(figsize=(7.0, 5.0)) #specify figure size (width, height) in inches'
#####plt.pcolormesh(wav_edges, z_edges*1.e-5, tau_n_tot_z_wav, cmap='Reds',vmin=0., vmax=1.)
#####plt.xlabel('Wavelength (nm)')
#####plt.ylabel('Altitude (z)')
#####plt.title('Optical Depth of Layers')
#####plt.colorbar()

#####fig=plt.figure(figsize=(7.0, 5.0)) #specify figure size (width, height) in inches'
#####plt.pcolormesh(wav_edges, z_edges*1.e-5, potato, cmap='Reds',vmin=0., vmax=4)
#####plt.xlabel('Wavelength (nm)')
#####plt.ylabel('Altitude (z)')
#####plt.title('Intensity Relative to Incident')
#####plt.colorbar()

##Print diagnostics useful for checking the absorption limit
#toprint=np.zeros([np.size(wav_centers), 7])
#toprint[:,0]=wav_leftedges
#toprint[:,1]=wav_rightedges
#toprint[:,2]=wav_centers
#toprint[:,3]=intensity_toa
#toprint[:,4]=surface_flux
#toprint[:,5]=surface_direct_flux
#toprint[:,6]=surface_diffuse_flux


#header='Left Bin Edge (nm)	Right Bin Edge (nm)	Bin Center (nm)		Top of Atm Intensity (erg/s/nm/cm2)		Total Surface Flux (erg/s/nm/cm2)		Total Direct Surface Flux (erg/s/nm/cm2)		Total Diffuse Surface Flux (erg/s/nm/cm2)\n'
#f=open(writefilename+'_difdir_v2.dat', 'w')
#f.write(header)
#np.savetxt(f, toprint, delimiter='		', fmt='%1.7e', newline='\n')
#f.close()

##thunk=surface_diffuse_flux/surface_flux
##print thunk
##bunk=surface_diffuse_flux/(flux_toa*mu_0)
##print bunk
##print np.max(bunk)

##Save the net flux, useful for checking the scattering limit
#fnetdict={'F_net':F_net, 'wav_leftedges':wav_leftedges,'wav_rightedges':wav_rightedges, 'wav_centers':wav_centers, 'z_lower':z_lower, 'z_upper':z_upper, 'z_center':z_center, 'flux_toa':intensity_toa, 'solarzenithangle':solarzenithangle}
#pickle.dump(fnetdict, open(writefilename+'fnet_v2.p', 'wb'))

#F_net_deviation=np.zeros(np.shape(F_net))
#F_net_deviation_max=np.zeros(N_wavelengths)
#F_net_deviation_max_normalized=np.zeros(N_wavelengths)
#F_net_deviation_stddevs=np.zeros(N_wavelengths)
#for ind in range(0, N_wavelengths):
	#median_val=np.median(F_net[:,ind])
	
	#F_net_deviation[:,ind]=F_net[:,ind]-median_val
	#F_net_deviation_max[ind]=np.max(np.abs(F_net_deviation[:,ind]))
	#F_net_deviation_stddevs[ind]=np.std(F_net[:,ind])

#F_net_deviation_max_normalized=F_net_deviation_max/(directflux_z_wav[0,:])
#F_net_deviation_stddevs_normalized=F_net_deviation_stddevs/(directflux_z_wav[0,:])

#print F_net_deviation_max_normalized
#print F_net_deviation_stddevs_normalized
##pdb.set_trace()